---
import { getRandomImage, getFileName } from "@components/Library.astro";
import { Image } from "astro:assets";
import type { ImageMetadata } from "astro";

interface Props {
  image?: {
    src: string;
    altText?: string;
    sourceType?: "local" | "remote";
  };
  imagePath?: string; // legacy or simplified usage
  altText?: string;
  twCSS?: string;
  maxWidth?: number;
  sourceType?: "local" | "remote";
  showCaption?: boolean;
  fallbackSrc?: string;
  [key: string]: any;
}

const {
  image,
  imagePath,
  altText: altTextProp,
  twCSS = "",
  maxWidth = 800,
  sourceType: sourceTypeProp,
  showCaption = false,
  fallbackSrc = "/placeholder.svg",
  ...rest
} = Astro.props as Props;

// üîç Determine final imagePath and sourceType
function isImageObject(obj: unknown): obj is { src: string } {
  return typeof obj === "object" && obj !== null && "src" in obj;
}

const resolvedImagePath =
  typeof imagePath === "string"
    ? imagePath
    : isImageObject(imagePath)
      ? imagePath.src
      : typeof image?.src === "string"
        ? image.src
        : undefined;

const resolvedAltText = altTextProp ?? image?.altText ?? "Untitled";
const resolvedSourceType = sourceTypeProp ?? image?.sourceType ?? "local";

// üîç Debug: Inspect resolved values
// console.log("üß™ ImageCard DEBUG ‚Äî raw props:", Astro.props);
// console.log(
//   "üß™ ImageCard DEBUG ‚Äî resolvedImagePath type:",
//   typeof resolvedImagePath
// );
// console.log("üß™ ImageCard DEBUG ‚Äî resolvedImagePath value:", resolvedImagePath);
// console.log("üß™ ImageCard DEBUG ‚Äî resolvedSourceType:", resolvedSourceType);

// Import all images from the specified directory.
const images: Record<string, () => Promise<{ default: ImageMetadata }>> =
  import.meta.glob<{ default: ImageMetadata }>(
    "/src/assets/images/*.{jpeg,jpg,png,gif,svg}"
  );

// üß† Ensure resolvedImagePath is a string before extracting filename
const safePath =
  typeof resolvedImagePath === "string"
    ? resolvedImagePath
    : typeof resolvedImagePath === "object" &&
        resolvedImagePath !== null &&
        "src" in resolvedImagePath
      ? resolvedImagePath.src
      : undefined;

// ‚úÖ Extract filename only if safePath is valid
const imageName = safePath ? getFileName(safePath) : undefined;

// ‚úÖ Construct imageKey only if imageName yields a valid match
const imageKey =
  imageName && images[`/src/assets/images/${imageName}`]
    ? `/src/assets/images/${imageName}`
    : getRandomImage(images);

// Error handling for image retrieval
if (resolvedSourceType === "local" && (!imageKey || !images[imageKey])) {
  console.error("‚ùå No valid local image found for key:", imageKey);
  return;
}

// Asynchronously get the image if local
let imageMeta: ImageMetadata | undefined = undefined;
if (resolvedSourceType === "local") {
  const imageModule = await images[imageKey]();
  imageMeta = imageModule.default;
}
---

<div class={twCSS}>
  {
    resolvedSourceType === "local" && imageMeta ? (
      <figure>
        <Image
          src={imageMeta}
          alt={resolvedAltText}
          width={maxWidth}
          loading="lazy"
          {...rest}
        />
        {showCaption && resolvedAltText ? (
          <figcaption class="mt-2 text-center text-sm text-gray-600">
            {resolvedAltText}
          </figcaption>
        ) : null}
      </figure>
    ) : (
      <figure>
        <img
          src={resolvedImagePath ?? fallbackSrc}
          alt={resolvedAltText}
          width={maxWidth}
          loading="lazy"
          onerror={`this.onerror=null;this.src='${fallbackSrc}'`}
          {...rest}
        />
        {showCaption && resolvedAltText ? (
          <figcaption class="mt-2 text-center text-sm text-gray-600">
            {resolvedAltText}
          </figcaption>
        ) : null}
      </figure>
    )
  }
</div>
