---
import { SkiCycleRunConfig } from "skicyclerun.config";
import { cognitoConfig } from "@config/cognito";
import "@styles/base.css";
import "@styles/prose-fix.css"; // Import our prose fix for Tailwind v4
import "@styles/auth-styles.css"; // Import auth-related styles
import "@styles/searchbar.css"; // Import search-related styles
import Footer from "@components/Footer.astro";
import PasswordlessAuthDialog from "@components/PasswordlessAuthDialog";

export interface Props {
  title?: string;
  author?: string;
  description?: string;
  ogImage?: string;
  canonicalURL?: string;
  pubDatetime?: Date;
  modDatetime?: Date | null;
  scrollSmooth?: boolean;
}

const {
  title = SkiCycleRunConfig.title,
  author = SkiCycleRunConfig.author,
  description = SkiCycleRunConfig.description,
  ogImage = SkiCycleRunConfig.ogImage,
  canonicalURL = new URL(Astro.url.pathname, Astro.site).href,
  pubDatetime,
  modDatetime,
  scrollSmooth = false,
} = Astro.props;

const socialImageURL = new URL(
  ogImage ?? SkiCycleRunConfig.ogImage ?? "og.png",
  Astro.url.origin
).href;

const authBridgeVars = {
  cognito: {
    domain: cognitoConfig.domain,
    clientId: cognitoConfig.clientId,
    scopes: cognitoConfig.scopes,
    redirectUri: cognitoConfig.redirectUri,
    logoutUri: cognitoConfig.logoutUri,
  },
};
---

<!doctype html>
<html
  lang=`${SkiCycleRunConfig.locale.lang ?? "en"}`
  class={`${scrollSmooth && "scroll-smooth"}`}
>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="canonical" href={canonicalURL} />
    <meta name="generator" content={Astro.generator} />

    <!-- General Meta Tags -->
    <title>{title}</title>
    <meta name="title" content={title} />
    <meta name="description" content={description} />
    <meta name="author" content={author} />
    <link rel="sitemap" href="/sitemap-index.xml" />

    <!-- Open Graph / Facebook -->
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:url" content={canonicalURL} />
    <meta property="og:image" content={socialImageURL} />

    <!-- Article Published/Modified time -->
    {
      pubDatetime && (
        <meta
          property="article:published_time"
          content={pubDatetime.toISOString()}
        />
      )
    }
    {
      modDatetime && (
        <meta
          property="article:modified_time"
          content={modDatetime.toISOString()}
        />
      )
    }

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content={canonicalURL} />
    <meta property="twitter:title" content={title} />
    <meta property="twitter:description" content={description} />
    <meta property="twitter:image" content={socialImageURL} />

    <meta name="theme-color" content="" />

    <!-- Debug state for inline scripts -->
    <meta
      name="debug-enabled"
      content={import.meta.env.PUBLIC_DEBUG_OUTPUT === "true"
        ? "true"
        : "false"}
    />

    <!-- Load debug helper for inline scripts (loads before inline scripts run) -->
    <script is:inline src="/scripts/debug-helper.js"></script>
    <script src="/toggle-theme.js" defer></script>
  </head>
  <body data-site-version={SkiCycleRunConfig.version}>
    <span class="sr-only">Version {SkiCycleRunConfig.version}</span>
    {
      /** Global, minimal auth icon handler (uses localStorage tokens, toggles #auth-btn icons) */
    }
    <!-- Auth bridge inline script to handle OAuth redirect -->
    <script is:inline define:vars={{ cognito: authBridgeVars.cognito }}>
      // Handle OAuth redirect and token exchange
      (async function () {
        // Use global debug helpers (loaded from debug-helper.js)
        const debug = window.debugLog
          ? (cat, ...args) => window.debugLog(cat, ...args)
          : () => {};
        const debugError = window.debugError
          ? (cat, ...args) => window.debugError(cat, ...args)
          : () => {};

        const TOKEN_KEYS = {
          idToken: "cognito_id_token",
          accessToken: "cognito_access_token",
          refreshToken: "cognito_refresh_token",
        };

        function parseJWT(token) {
          try {
            const base64Url = token.split(".")[1];
            const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
            const jsonPayload = decodeURIComponent(
              atob(base64)
                .split("")
                .map(
                  (c) => "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2)
                )
                .join("")
            );
            return JSON.parse(jsonPayload);
          } catch {
            return null;
          }
        }

        function isTokenExpired(token) {
          const payload = parseJWT(token);
          if (!payload || !payload.exp) return true;
          return Date.now() >= payload.exp * 1000;
        }

        function clearTokens() {
          try {
            Object.values(TOKEN_KEYS).forEach((key) =>
              localStorage.removeItem(key)
            );
            debug("auth", "Tokens cleared");
          } catch (e) {
            debugError("auth", "Failed to clear tokens:", e);
          }
        }

        function getStoredTokens() {
          try {
            return {
              idToken: localStorage.getItem(TOKEN_KEYS.idToken) || undefined,
              accessToken:
                localStorage.getItem(TOKEN_KEYS.accessToken) || undefined,
              refreshToken:
                localStorage.getItem(TOKEN_KEYS.refreshToken) || undefined,
            };
          } catch {
            return {};
          }
        }

        function getAuthState() {
          const tokens = getStoredTokens();
          if (!tokens.idToken || isTokenExpired(tokens.idToken)) {
            return { signedIn: false };
          }
          const payload = parseJWT(tokens.idToken);
          if (!payload) {
            return { signedIn: false };
          }
          return {
            signedIn: true,
            email: payload.email || null,
            groups: payload["cognito:groups"] || [],
            idToken: tokens.idToken,
            accessToken: tokens.accessToken,
          };
        }

        function openPasswordlessDialog() {
          const dialog = window.__passwordlessAuth;
          if (dialog && typeof dialog.open === "function") {
            dialog.open();
          } else {
            debugError("auth", "Passwordless dialog not available");
          }
        }

        function logout() {
          clearTokens();
          document.dispatchEvent(
            new CustomEvent("auth:state-change", {
              detail: { isAuthenticated: false },
            })
          );
          debug("auth", "Logged out");
        }

        // Setup window.__authBridge for passwordless only
        window.__authBridge = {
          login: openPasswordlessDialog,
          loginPasswordless: openPasswordlessDialog,
          logout: logout,
          getState: getAuthState,
          getIdToken: () => {
            const tokens = getStoredTokens();
            return tokens.idToken && !isTokenExpired(tokens.idToken)
              ? tokens.idToken
              : null;
          },
          getAccessToken: () => {
            const tokens = getStoredTokens();
            return tokens.accessToken && !isTokenExpired(tokens.accessToken)
              ? tokens.accessToken
              : null;
          },
        };
        debug("auth", "Passwordless auth bridge ready");
      })();
    </script>
    <!-- Load auth icon script from public folder (external, defer to avoid inline CSP) -->
    <script src="/scripts/simple-auth-icon.js" defer></script>
    <slot />
    <PasswordlessAuthDialog client:load />
    <Footer />
  </body>
</html>
