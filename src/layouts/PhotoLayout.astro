---
import { SkiCycleRunConfig } from "../skicyclerun.config";
import { getAlbumPhotos } from "@components/Library.astro";
import MDXCarousel3 from "./MDXCarousel3.astro";
import MDXHeroView from "./MDXHeroView.astro";
import MDXGalleryView from "./MDXGalleryView.astro";

const { frontmatter } = Astro.props;
const album = frontmatter?.album;
if (!album) throw new Error("PhotoLayout requires frontmatter.album to be set");

const photos = await getAlbumPhotos(album);
if (!photos || photos.length === 0) {
  // Render a friendly fallback instead of throwing to avoid breaking the page
  console.warn(`Album \"${album}\" returned no photos`);
}
---

<article class="photo-layout" data-album={album}>
  <header class="mb-2">
    {
      frontmatter.title && (
        <h1 class="text-3xl font-bold">{frontmatter.title}</h1>
      )
    }
    {
      frontmatter.description && (
        <p class="text-skin-muted mt-2">{frontmatter.description}</p>
      )
    }
  </header>

  <div class="relative mb-2">
    <!-- Click hint tooltip - positioned on same line as radio controls, centered -->
    <div
      id="click-hint"
      class="absolute top-1/2 -translate-y-1/2 left-1/2 -translate-x-1/2 transition-opacity duration-500 animate-bounce"
      style="z-index: 30; pointer-events: none;"
    >
      <div
        class="bg-skin-accent text-skin-inverted text-base font-medium px-3 py-1.5 rounded-full shadow-lg whitespace-nowrap border border-skin-line"
      >
        ðŸ‘‡ Tap photo
      </div>
    </div>

    <nav class="flex justify-end" aria-label="Photo view selector">
      <div class="flex gap-4">
        <label class="cursor-pointer">
          <input type="radio" name="photo-view" value="hero" /> Hero
        </label>
        <label class="cursor-pointer">
          <input type="radio" name="photo-view" value="gallery" checked /> Gallery
        </label>
        <label class="cursor-pointer">
          <input type="radio" name="photo-view" value="carousel" /> Carousel
        </label>
      </div>
    </nav>
  </div>

  <div class="relative">
    <section class="photo-view relative">
      <div id="photo-hero" style="display:none">
        <MDXHeroView photos={photos} frontmatter={frontmatter} />
      </div>
      <div id="photo-gallery">
        <MDXGalleryView photos={photos} frontmatter={frontmatter} />
      </div>
      <div id="photo-carousel" style="display:none">
        <MDXCarousel3 photos={photos} />
      </div>
    </section>
  </div>

  <div class="mt-4 flex flex-wrap items-center justify-center gap-3 text-sm">
    <label for="lora-style" class="font-medium">Art Style:</label>
    <select
      id="lora-style"
      class="px-3 py-1.5 rounded border border-skin-line bg-skin-fill text-skin-base cursor-pointer"
    >
      <option value="random" selected>Random Mix</option>
      <option value="Afremov">Afremov</option>
      <option value="Gorillaz">Gorillaz</option>
      <option value="Origami">Origami</option>
      <option value="PencilDrawing">Pencil Drawing</option>
      <option value="FractalGeometry">Fractal Geometry</option>
    </select>
    <span class="text-skin-muted">Â·</span>
    <label class="cursor-pointer flex items-center gap-2">
      <input type="checkbox" id="use-dynamic" class="cursor-pointer" />
      <span class="font-medium"
        >Full Image Library <span class="text-skin-muted italic">(slower)</span
        ></span
      >
    </label>
  </div>

  <div id="dynamic-loading" style="display:none" class="dynamic-loading">
    <p>Loading full image library from API...</p>
    <div class="spinner"></div>
  </div>

  <!-- Render page MDX content inside the master layout -->
  <slot />

  <script
    define:vars={{
      dynamicPhotosCount: SkiCycleRunConfig.photoApi.dynamicPhotos,
    }}
  >
    document.addEventListener("DOMContentLoaded", function () {
      const radios = Array.from(
        document.querySelectorAll('input[name="photo-view"]')
      );
      const dynamicCheckbox = document.getElementById("use-dynamic");
      const loraSelect = document.getElementById("lora-style");
      const album = document
        .querySelector(".photo-layout")
        ?.getAttribute("data-album");
      const loadingEl = document.getElementById("dynamic-loading");
      const clickHint = document.getElementById("click-hint");

      const sections = {
        hero: document.getElementById("photo-hero"),
        gallery: document.getElementById("photo-gallery"),
        carousel: document.getElementById("photo-carousel"),
      };

      // Hide click hint after first interaction or after 15 seconds
      // Hide click hint after first interaction or after 3 seconds
      let hintDismissed = false;
      const dismissHint = () => {
        if (!hintDismissed && clickHint) {
          hintDismissed = true;
          clickHint.style.opacity = "0";
          setTimeout(() => {
            clickHint.style.display = "none";
          }, 500);
        }
      };

      // Auto-dismiss hint after 3 seconds
      setTimeout(dismissHint, 3000);
      // Dismiss on any click in photo view area
      document
        .querySelector(".photo-view")
        ?.addEventListener("click", dismissHint, { once: true });

      let dynamicPhotosLoaded = false;
      let dynamicPhotos = [];
      let staticPhotos = []; // Store original static photos
      let currentLoraStyle = "random"; // Default

      // Get initial static photos from the page (try all views)
      function getStaticPhotos() {
        // Try hero view first
        for (const [viewName, viewDiv] of Object.entries(sections)) {
          if (viewDiv) {
            const scriptTag = viewDiv.querySelector(
              'script[type="application/json"]'
            );
            if (scriptTag) {
              try {
                const photos = JSON.parse(scriptTag.textContent || "[]");
                if (photos.length > 0) {
                  console.log(
                    `[PhotoLayout] Found ${photos.length} static photos in ${viewName} view`
                  );
                  return photos;
                }
              } catch (e) {
                console.warn(
                  `[PhotoLayout] Failed to parse static photos from ${viewName}:`,
                  e
                );
              }
            }
          }
        }
        console.warn("[PhotoLayout] No static photos found in any view");
        return [];
      }

      // Filter static photos by art style
      function filterStaticPhotosByStyle(photos, style) {
        console.log(
          `[PhotoLayout] filterStaticPhotosByStyle called with ${photos.length} photos, style: ${style}`
        );

        if (style === "random" || !style) {
          console.log(
            "[PhotoLayout] No filtering - showing all photos (random)"
          );
          return photos;
        }

        const filtered = photos.filter((photo) => {
          // First check for explicit loraStyle property
          let loraStyle =
            photo.loraStyle ||
            photo.lora_style ||
            photo.LoraStyle ||
            photo.style;

          // If no property, extract from filename
          // Format: IMG_####_StyleName_########.webp
          if (!loraStyle && photo.src) {
            const filename = photo.src.split("/").pop(); // Get filename
            const match = filename.match(/_([A-Za-z]+)_\d+\./); // Match _StyleName_digits.
            if (match && match[1]) {
              loraStyle = match[1];
            }
          }

          const matches = loraStyle === style;
          console.log(
            `[PhotoLayout] Photo: ${photo.src.split("/").pop()}, extracted style: ${loraStyle}, matches ${style}: ${matches}`
          );
          return matches;
        });

        console.log(
          `[PhotoLayout] Filtered ${photos.length} photos to ${filtered.length} for style: ${style}`
        );

        // If filtering resulted in no photos, return all photos instead of empty array
        if (filtered.length === 0) {
          console.warn(
            `[PhotoLayout] No photos match style "${style}", returning all photos instead`
          );
          return photos;
        }

        return filtered;
      }

      async function loadDynamicPhotos(loraStyle = "random") {
        // Reset cache if style changed
        if (currentLoraStyle !== loraStyle) {
          console.log(
            `[PhotoLayout] LoRA style changed from ${currentLoraStyle} to ${loraStyle} - invalidating cache`
          );
          dynamicPhotosLoaded = false;
          currentLoraStyle = loraStyle;
        }

        if (dynamicPhotosLoaded && dynamicPhotos.length > 0) {
          console.log(
            `[PhotoLayout] Using cached dynamic photos for style: ${loraStyle}`
          );
          return dynamicPhotos;
        }

        if (!album) return [];

        try {
          if (loadingEl) loadingEl.style.display = "flex";

          const baseUrl =
            window.PUBLIC_SKICYCLERUN_API || "https://api.skicyclerun.com/v2/";
          const loraParam =
            loraStyle === "random" ? "" : `&loraStyle=${loraStyle}`;
          const photoURL = `${baseUrl}getphotosrandom?bucketName=skicyclerun.lib&albumPath=albums/${album}/&numPhotos=${dynamicPhotosCount}${loraParam}`;

          console.log(`[PhotoLayout] Fetching photos from API: ${photoURL}`);
          const res = await fetch(photoURL);
          const data = await res.json();

          if (Array.isArray(data) && data.length > 0) {
            dynamicPhotos = data.map((p, i) => {
              const src = typeof p === "string" ? p : p?.src;
              return {
                src,
                altText: p?.altText || `Photo ${i + 1}`,
                sourceType: "remote",
              };
            });
            dynamicPhotosLoaded = true;
            console.log(
              `âœ… Loaded ${dynamicPhotos.length} photos from API with style: ${loraStyle}`
            );
          } else {
            console.warn("No photos returned from API");
          }

          if (loadingEl) loadingEl.style.display = "none";
          return dynamicPhotos;
        } catch (error) {
          console.error("Failed to load dynamic photos:", error);
          if (loadingEl) {
            loadingEl.innerHTML =
              '<p class="error">Failed to load photos from API</p>';
            setTimeout(() => {
              if (loadingEl) loadingEl.style.display = "none";
            }, 3000);
          }
          return [];
        }
      }

      function updateViewContent(photos) {
        console.log(
          `[PhotoLayout] Updating view content with ${photos.length} photos`
        );

        // Update Hero view
        const heroContainer = sections.hero;
        if (heroContainer && photos.length > 0) {
          // Update the JSON data that Hero view uses for navigation
          const heroJsonScript = heroContainer.querySelector(
            'script[type="application/json"]#hero-photos'
          );
          if (heroJsonScript) {
            heroJsonScript.textContent = JSON.stringify(photos).replace(
              /</g,
              "\\u003c"
            );
            console.log("[PhotoLayout] Hero JSON updated");
          }

          const heroImg = heroContainer.querySelector("img");
          if (heroImg && photos[0]) {
            heroImg.src = photos[0].src;
            heroImg.alt = photos[0].altText || "Photo";
            heroImg.dataset.currentIndex = "0"; // Reset to first image
            console.log("[PhotoLayout] Hero image updated to:", photos[0].src);
          }

          // Remove old event listeners by cloning the image element
          if (heroImg) {
            const heroFigure = heroContainer.querySelector(
              "figure[data-photos-json]"
            );
            if (heroFigure) {
              delete heroFigure.dataset.heroInitialized;

              // Clone image to remove all event listeners
              const newImg = heroImg.cloneNode(true);
              heroImg.parentNode?.replaceChild(newImg, heroImg);

              // Re-attach click handler with new photos array
              newImg.addEventListener("click", () => {
                let idx = Number(newImg.dataset.currentIndex) || 0;
                idx = (idx + 1) % photos.length;
                newImg.dataset.currentIndex = String(idx);
                const p = photos[idx];
                if (p) {
                  newImg.src = p.src;
                  newImg.alt = p.altText || `Photo ${idx + 1}`;
                  console.log(
                    `[PhotoLayout] Hero clicked - showing photo ${idx + 1}/${photos.length}`
                  );
                }
              });
              console.log(
                "[PhotoLayout] Hero click handler reattached with new photos"
              );
            }
          }
        }

        // Update Gallery view - find all gallery images
        const galleryContainer = sections.gallery;
        if (galleryContainer && photos.length > 0) {
          const galleryDiv = galleryContainer.querySelector(".mdx-gallery");
          if (galleryDiv) {
            // Remove initialization flag to force re-initialization
            delete galleryDiv.dataset.galleryInitialized;

            // Update the JSON data for gallery
            const galleryJsonScript = galleryContainer.querySelector(
              'script[type="application/json"]#gallery-photos'
            );
            if (galleryJsonScript) {
              galleryJsonScript.textContent = JSON.stringify(photos).replace(
                /</g,
                "\\u003c"
              );
              console.log("[PhotoLayout] Gallery JSON updated");
            }

            // Get gallery grid and recreate the click handlers
            const grid = galleryDiv.querySelector(".grid");
            if (grid) {
              const matrix =
                Number(galleryDiv.getAttribute("data-gallery-matrix")) || 2;
              const visibleCount = matrix * matrix;
              let visibleIndices = Array.from(
                { length: visibleCount },
                (_, i) => i % photos.length
              );

              const slots = Array.from(
                grid.querySelectorAll("[data-slot-index]")
              );

              function renderSlot(slotEl, photo) {
                slotEl.innerHTML = "";
                if (!photo) {
                  const ph = document.createElement("div");
                  ph.className = "placeholder";
                  slotEl.appendChild(ph);
                  return;
                }
                const img = document.createElement("img");
                img.src = photo.src;
                img.alt = photo.alt || photo.altText || "";
                img.loading = "lazy";
                img.decoding = "async";
                img.style.width = "100%";
                img.style.height = "100%";
                img.style.objectFit = "cover";
                img.style.display = "block";
                slotEl.appendChild(img);
              }

              function renderVisible() {
                slots.forEach((s, i) => {
                  const photo = photos[visibleIndices[i]] || null;
                  renderSlot(s, photo);
                });
              }

              // Initial render with new photos
              renderVisible();

              // Remove old click handlers by cloning each slot
              slots.forEach((slot, idx) => {
                const newSlot = slot.cloneNode(true);
                slot.parentNode?.replaceChild(newSlot, slot);
                slots[idx] = newSlot; // Update reference

                // Re-attach click handler with new photos array
                newSlot.style.cursor = "pointer";
                newSlot.addEventListener("click", () => {
                  // Rotate visibleIndices clockwise
                  const last = visibleIndices.pop();
                  visibleIndices.unshift((last + 1) % photos.length);
                  console.log(
                    `[PhotoLayout] Gallery rotated indices:`,
                    visibleIndices
                  );
                  renderVisible();
                });
              });

              console.log(
                `[PhotoLayout] Gallery reinitialized with ${photos.length} photos`
              );
            }
          }
        }

        // Update Carousel view
        const carouselContainer = sections.carousel;
        if (carouselContainer) {
          // Update the JSON data for carousel
          const carouselJsonScript = carouselContainer.querySelector(
            'script[type="application/json"]'
          );
          if (carouselJsonScript) {
            carouselJsonScript.textContent = JSON.stringify(photos).replace(
              /</g,
              "\\u003c"
            );
            console.log("[PhotoLayout] Carousel JSON updated");
          }

          // Find the carousel track and slides
          const track = carouselContainer.querySelector(".carousel-track");
          if (track) {
            const slides = Array.from(
              track.querySelectorAll(".carousel-slide")
            );

            // Update each slide's data-src and image
            slides.forEach((slide, i) => {
              if (photos[i]) {
                slide.setAttribute("data-src", photos[i].src);
                const img = slide.querySelector("img");
                if (img) {
                  img.src = photos[i].src;
                  img.alt = photos[i].altText || `Photo ${i + 1}`;
                }
              }
            });

            // Reset carousel to first slide and reinitialize
            if (carouselContainer.dataset.carouselInitialized) {
              delete carouselContainer.dataset.carouselInitialized;

              // Clear any existing interval
              const intervalId = carouselContainer.dataset.carouselInterval;
              if (intervalId) {
                clearInterval(Number(intervalId));
                delete carouselContainer.dataset.carouselInterval;
              }

              // Reset transform
              track.style.transform = "translateX(0%)";

              // Trigger re-initialization by dispatching event
              const event = new CustomEvent("reinit-carousel", {
                detail: { containerId: carouselContainer.id },
              });
              document.dispatchEvent(event);
            }

            console.log(
              `[PhotoLayout] Carousel slides updated with ${slides.length} photos and reinitialized`
            );
          }
        }
      }

      async function update() {
        console.log("[PhotoLayout] update() called");

        const checked = document.querySelector(
          'input[name="photo-view"]:checked'
        );
        const value = checked ? checked.getAttribute("value") : "gallery";
        const useDynamic = dynamicCheckbox?.checked || false;
        const loraStyle = loraSelect?.value || "random";

        console.log(
          `[PhotoLayout] Current view: ${value}, useDynamic: ${useDynamic}, loraStyle: ${loraStyle}`
        );

        // Show/hide views based on radio selection
        Object.keys(sections).forEach((k) => {
          const el = sections[k];
          if (!el) return;
          el.style.display = k === value ? "" : "none";
        });

        if (useDynamic) {
          // Full Image Library checked - load from API
          console.log("[PhotoLayout] Loading dynamic photos from API...");
          const photos = await loadDynamicPhotos(loraStyle);
          if (photos.length > 0) {
            updateViewContent(photos);
          }
        } else {
          // Full Image Library unchecked - filter static photos by art style
          console.log("[PhotoLayout] Using static photos, will filter...");
          if (staticPhotos.length === 0) {
            console.log("[PhotoLayout] staticPhotos empty, loading now...");
            staticPhotos = getStaticPhotos();
          }
          console.log(
            `[PhotoLayout] Have ${staticPhotos.length} static photos before filtering`
          );

          const filteredPhotos = filterStaticPhotosByStyle(
            staticPhotos,
            loraStyle
          );
          console.log(
            `[PhotoLayout] After filtering: ${filteredPhotos.length} photos`
          );

          if (filteredPhotos.length > 0) {
            console.log(
              "[PhotoLayout] Calling updateViewContent with filtered photos..."
            );
            updateViewContent(filteredPhotos);
          } else {
            console.warn("[PhotoLayout] No filtered photos to display!");
          }
        }
      }

      radios.forEach((r) => r.addEventListener("change", update));

      // Handle checkbox change - toggles between static filtered and dynamic API photos
      dynamicCheckbox?.addEventListener("change", update);

      // Handle LoRA style changes - always triggers update (filters static or loads dynamic)
      loraSelect?.addEventListener("change", async function () {
        console.log(
          "[PhotoLayout] Art style dropdown changed to:",
          loraSelect.value
        );
        await update();
      });

      // Initialize static photos AFTER DOM is ready
      console.log("[PhotoLayout] Starting initialization...");

      // Small delay to ensure all views are rendered
      setTimeout(() => {
        staticPhotos = getStaticPhotos();
        console.log(
          `[PhotoLayout] Initialized with ${staticPhotos.length} static photos`
        );

        if (staticPhotos.length > 0) {
          // Log some sample data to verify structure
          console.log("[PhotoLayout] Sample photo structure:", staticPhotos[0]);
        }

        // Apply initial view and filter
        update();
      }, 100);
    });
  </script>
</article>

<style>
  .photo-layout {
    max-width: 72rem;
    margin: 0 auto;
    padding: 0 1rem;
  }

  /* Keep the photo view area a fixed viewport so hero/gallery/carousel share same box */
  .photo-view > div {
    width: 100%;
    max-width: 1024px;
    margin-left: auto;
    margin-right: auto;
    aspect-ratio: 1 / 1;
    background: rgb(var(--color-fill));
    position: relative;
    overflow: hidden;
  }

  /* Loading overlay */
  .dynamic-loading {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 200px;
    gap: 1rem;
    padding: 2rem;
  }

  .spinner {
    width: 40px;
    height: 40px;
    border: 4px solid rgba(var(--color-text-base), 0.1);
    border-left-color: rgb(var(--color-accent));
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

  .error {
    color: rgb(var(--color-text-muted));
    text-align: center;
    padding: 2rem;
  }
</style>
